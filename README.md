# SE-Lab1-Frontend
Static frontend with Git flow and CI/CD via GitHub Actions for Software Engineering Lab 1

### ۱. پوشه‌ی .git چیست؟
این پوشه مخزن اصلی اطلاعات و "مغز" گیت در پروژه است. اگر این پوشه حذف شود، تاریخچه پروژه از بین رفته و پوشه به یک دایرکتوری معمولی تبدیل می‌شود.
اطلاعات ذخیره شده:
- Object Database: تمام محتوای فایل‌ها، کامیت‌ها و درخت‌ها (Trees) به صورت فشرده در `objects/`.
- References (Refs): اشاره‌گرهایی به شاخه‌ها (Branches) و تگ‌ها در `refs/`.
- HEAD: فایلی که مشخص می‌کند هم‌اکنون روی کدام شاخه یا کامیت هستیم.
- Config: تنظیمات محلی پروژه (مثل remote url).
- Hooks: اسکریپت‌های خودکارسازی قبل/بعد از کامیت و...


**دستور ساخت:**
این پوشه با دستور `git init` ایجاد می‌شود. (همچنین دستور `git clone` نیز به طور خودکار آن را می‌سازد).


### ۲. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟
"اتمیک" بودن در مهندسی نرم‌افزار به مفهومی از "تجزیه‌ناپذیری" اشاره دارد. یعنی یک عملیات یا به طور کامل و موفق انجام می‌شود، یا اصلاً انجام نمی‌شود و هیچ اثر جانبی نیمه‌کاره‌ای باقی نمی‌گذارد.

-   **Atomic Commit:** یک کامیت اتمیک، کوچک‌ترین واحد منطقی و کامل از یک تغییر را در خود جای می‌دهد. به جای ثبت کردن چندین تغییر نامرتبط (مثلاً "رفع باگ پرداخت و تغییر رنگ هدر")، هر کامیت فقط و فقط یک کار را انجام می‌دهد (مثلاً "Feat: Add user authentication endpoint"). این کار بازبینی کد (Code Review)، بازگردانی تغییرات (Revert) و درک تاریخچه پروژه را بسیار ساده‌تر می‌کند.

-   **Atomic Pull-Request:** این مفهوم نیز مشابه است. یک PR اتمیک باید یک دغدغه یا فیچر خاص را حل کند. PR نباید مجموعه‌ای از چندین فیچر، باگ‌فیکس و ریفکتور نامرتبط باشد. یک PR اتمیک به ریویوئر اجازه می‌دهد تمرکز کند، سریع‌تر آن را بررسی و تأیید کند و در صورت بروز مشکل، کل تغییر با اطمینان بیشتری قابل بازگشت است.


### ۳. دستور `git reflog` چیست و چه کاربردی دارد؟
`git reflog` (Reference Log) یک مکانیزم داخلی در گیت است که تاریخچه‌ای از تمام تغییرات اشاره‌گر `HEAD` را ثبت می‌کند. به زبان ساده‌تر، این دستور تمام کارهایی که در مخزن محلی (Local Repository) خود انجام داده‌اید—مانند `checkout` کردن بین شاخه‌ها، `commit` کردن، `reset` کردن، یا `merge` کردن—را به ترتیب زمانی نگه می‌دارد.

**تفاوت با `git log`:**
-   `git log` تاریخچه خطی و عمومی کامیت‌های پروژه را نشان می‌دهد که بین تمام اعضای تیم به اشتراک گذاشته می‌شود.
-   `git reflog` تاریخچه خصوصی و محلی شماست. این لاگ هیچ‌وقت به مخزن ریموت (Remote) پوش نمی‌شود و فقط روی سیستم شما وجود دارد.

**کاربرد اصلی:**
**نجات دادن پروژه!** `reflog` برای بازیابی کامیت‌ها یا شاخه‌هایی که به نظر "حذف شده" یا "گم شده" می‌آیند، حیاتی است. برای مثال:
-   اگر با `git reset --hard` یک کامیت را حذف کنید، در `git log` دیگر دیده نمی‌شود، اما در `reflog` هنوز قابل دسترسی است.
-   اگر یک شاخه را به اشتباه حذف کنید، `reflog` به شما نشان می‌دهد که آخرین کامیت آن شاخه چه بوده تا بتوانید آن را بازیابی کنید.

این دستور مانند یک دفترچه یادداشت شخصی برای گیت عمل می‌کند و به شما اجازه می‌دهد به هر نقطه‌ای از تاریخچه کاری خود بازگردید، حتی اگر آن نقاط در تاریخچه اصلی پروژه ثبت نشده باشند.


### ۴. دستور `git cherry-pick` چیست و چه کاربردی دارد؟
`git cherry-pick` دستوری است که به شما اجازه می‌دهد یک یا چند کامیت خاص را از یک شاخه انتخاب کرده و آن‌ها را روی شاخه فعلی خود اعمال کنید. به جای ادغام (merge) کردن تمام تغییرات یک شاخه، شما مانند یک "گیلاس‌چین" فقط کامیت‌های دلخواه خود را برمی‌دارید.

**سناریوی کاربرد:**
فرض کنید روی یک شاخه `feature/new-design` کار می‌کنید و متوجه یک باگ در سیستم لاگین می‌شوید. آن باگ را در یک کامیت جداگانه (`fix: correct login validation`) روی همان شاخه `feature` ثبت می‌کنید. حالا می‌خواهید این فیکس را فوراً به شاخه `main` یا `develop` منتقل کنید، بدون اینکه کل فیچر ناقص `new-design` را با آن همراه کنید.

**فرایند کار:**
1.  هش (Hash) کامیت مورد نظر را از `git log` پیدا می‌کنید (مثلاً `a1b2c3d`).
2.  به شاخه‌ای که می‌خواهید کامیت را به آن منتقل کنید، `checkout` می‌کنید (مثلاً `git checkout develop`).
3.  دستور را اجرا می‌کنید: `git cherry-pick a1b2c3d`.

گیت یک کپی از آن کامیت را روی شاخه `develop` ایجاد می‌کند. کامیت اصلی در شاخه مبدأ دست‌نخورده باقی می‌ماند.

**مزایا:**
-   **کنترل دقیق:** فقط تغییراتی که نیاز دارید را منتقل می‌کنید.
-   **جلوگیری از مرج‌های بزرگ و غیرضروری:** برای اعمال یک فیکس کوچک، نیازی به مرج کردن کل یک فیچر نیست.

**هشدار:** استفاده نادرست از `cherry-pick` می‌تواند منجر به ایجاد کامیت‌های تکراری (Duplicate Commits) در تاریخچه شود و آن را پیچیده کند. معمولاً برای Hotfixها یا انتقال تغییرات بسیار خاص استفاده می‌شود.


### ۵. دستور `git stash` چیست و چه کاربردی دارد؟
`git stash` یک ابزار قدرتمند برای ذخیره موقت تغییراتی است که هنوز برای کامیت شدن آماده نیستند. این دستور تمام تغییرات `staged` و `unstaged` شما را در یک "پشته" (stack) موقت ذخیره می‌کند و ورکینگ دایرکتوری شما را به حالت آخرین کامیت (`HEAD`) برمی‌گرداند.

**سناریوی کاربرد اصلی (تعویض زمینه یا Context-Switching):**
شما در حال کار روی یک فیچر هستید و چندین فایل را تغییر داده‌اید، اما کارتان نیمه‌کاره است و نمی‌خواهید یک کامیت ناقص ایجاد کنید. ناگهان یک باگ فوری گزارش می‌شود و باید سریعاً به شاخه `main` بروید تا آن را برطرف کنید. اگر تلاش کنید `checkout` کنید، گیت به دلیل وجود تغییرات کامیت‌نشده به شما خطا می‌دهد.

**راه حل `stash`:**
1.  `git stash`: تمام تغییرات فعلی شما ذخیره شده و ورکینگ دایرکتوری تمیز می‌شود.
2.  `git checkout main`: حالا به راحتی شاخه را عوض می‌کنید و Hotfix را اعمال می‌کنید.
3.  `git checkout feature-branch`: به شاخه قبلی خود برمی‌گردید.
4.  `git stash pop`: آخرین مجموعه تغییرات ذخیره‌شده را از پشته خارج کرده و دوباره روی ورکینگ دایرکتوری شما اعمال می‌کند.

**دستورات کلیدی:**
-   `git stash save "message"`: ذخیره تغییرات با یک پیام توصیفی.
-   `git stash list`: نمایش لیست تمام stash-ها.
-   `git stash pop`: اعمال آخرین stash و حذف آن از لیست.
-   `git stash apply`: اعمال آخرین stash اما نگه داشتن آن در لیست (برای استفاده مجدد).
-   `git stash drop`: حذف یک stash خاص.
