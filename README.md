# SE-Lab1-Frontend
Static frontend with Git flow and CI/CD via GitHub Actions for Software Engineering Lab 1




# گزارش نهایی پیاده‌سازی پروژه SE-Lab1-Frontend

این گزارش، خلاصه‌ای از فرآیندهای فنی اجرا شده برای راه‌اندازی و تکمیل پروژه `SE-Lab1-Frontend` است. تمامی مراحل، از ساختاردهی اولیه تا استقرار نهایی، با رعایت بهترین شیوه‌ها (Best Practices) در مهندسی نرم‌افزار و استفاده از Git انجام شده است.

---

### ۱. استراتژی شاخه‌بندی (Branching Strategy)

پروژه بر اساس یک مدل ساده‌شده از **Git Flow** سازماندهی شد تا توسعه، یکپارچه‌سازی و انتشار کد به صورت مدیریت‌شده انجام شود. شاخه‌های اصلی عبارتند از:

-   **`main`:** این شاخه، نماینده کد پایدار و نسخه‌های قابل انتشار (Production-Ready) است. هیچ توسعه مستقیمی روی این شاخه انجام نمی‌شود و کد فقط از طریق شاخه `develop` به آن منتقل می‌گردد. هر کامیت روی `main` یک نسخه قابل استقرار است.
-   **`develop`:** شاخه اصلی توسعه که تمام فیچرها پس از تکمیل در آن ادغام می‌شوند. این شاخه به عنوان محیط یکپارچه‌سازی (Integration) عمل می‌کند و همیشه آخرین نسخه در حال توسعه پروژه را در خود دارد.
-   **`feature/*`:** برای هر قابلیت جدید یا تغییر در پروژه، یک شاخه مجزا از `develop` با پیشوند `feature/` ایجاد شد (مانند `feature/project-structure` یا `feature/blue-header`). این رویکرد، توسعه موازی و ایزوله را ممکن ساخت. پس از تکمیل، هر شاخه فیچر به `develop` ادغام می‌شد.

### ۲. تاریخچه کامیت‌ها (Commit History)

یکی از اهداف اصلی پروژه، حفظ تاریخچه‌ای خوانا و معنادار بود. برای این منظور، تمام تغییرات در قالب **کامیت‌های اتمیک (Atomic Commits)** ثبت شدند. هر کامیت تنها یک تغییر منطقی را شامل می‌شود که این امر به شدت به موارد زیر کمک می‌کند:
-   **بازبینی کد (Code Review):** بررسی تغییرات کوچک و متمرکز بسیار ساده‌تر است.
-   **دیباگینگ:** با استفاده از ابزارهایی مانند `git bisect`، پیدا کردن کامیتِ عاملِ باگ تسریع می‌شود.
-   **بازگردانی تغییرات (Revert):** امکان بازگردانی یک تغییر خاص بدون تأثیر روی سایر بخش‌ها وجود دارد.

در مجموع، بیش از **۲۰ کامیت اتمیک** در تاریخچه پروژه ثبت گردید که نشان‌دهنده فرایند توسعه گام‌به‌گام و مدیریت‌شده است.

### ۳. مدیریت تضاد (Conflict Resolution)

برای شبیه‌سازی کار تیمی و مدیریت چالش‌های رایج در توسعه نرم‌افزار، دو سناریوی تضاد (Conflict) به صورت کنترل‌شده ایجاد و حل شد:

1.  **تضاد در استایل (Theme Conflict):** دو شاخه `feature/blue-header` و `feature/red-theme` تغییرات متناقضی را روی فایل‌های `index.html` و `style.css` اعمال کردند. پس از ادغام یکی پس از دیگری در `develop`، کانفلیکت ایجاد شده با استفاده از ابزار **Merge Editor** در VS Code حل و یک استایل ترکیبی به عنوان راه‌حل نهایی ثبت شد.
2.  **تضاد در داکیومنت (Documentation Conflict):** تغییرات متناقضی در فایل `README.md` در شاخه‌های مختلف ایجاد و سپس با موفقیت ادغام و حل گردید.

### ۴. استقرار خودکار (CI/CD) و انتشار

به منظور خودکارسازی فرآیند استقرار، یک پایپ‌لاین **CI/CD** با استفاده از **GitHub Actions** پیاده‌سازی شد.
-   فایل `workflow` در مسیر `.github/workflows/static.yml` تعریف گردید.
-   این workflow به محض هر `push` روی شاخه `main`، به صورت خودکار فعال شده، پروژه را Build کرده و آن را روی **GitHub Pages** مستقر می‌کند.

این فرآیند تضمین می‌کند که نسخه لایو سایت همیشه با آخرین کد پایدار در شاخه `main` همگام است.

**آدرس سایت نهایی:**
پروژه با موفقیت روی آدرس زیر در دسترس است:
[https://aradsheikhsalimi.github.io/SE-Lab1-Frontend/](https://aradsheikhsalimi.github.io/SE-Lab1-Frontend/)

### ۵. مستندسازی فنی

علاوه بر کد، مستندات پروژه نیز تکمیل شد. بخشی تحت عنوان **"سوالات تئوری"** به فایل `README.md` اضافه گردید که مفاهیم کلیدی و دستورات مهم Git در آن توضیح داده شده‌اند. هر پاسخ به صورت یک کامیت اتمیک جداگانه ثبت شد تا با استراتژی کلی پروژه هماهنگ باشد.







### ۱. پوشه‌ی .git چیست؟
این پوشه مخزن اصلی اطلاعات و "مغز" گیت در پروژه است. اگر این پوشه حذف شود، تاریخچه پروژه از بین رفته و پوشه به یک دایرکتوری معمولی تبدیل می‌شود.
اطلاعات ذخیره شده:
- Object Database: تمام محتوای فایل‌ها، کامیت‌ها و درخت‌ها (Trees) به صورت فشرده در `objects/`.
- References (Refs): اشاره‌گرهایی به شاخه‌ها (Branches) و تگ‌ها در `refs/`.
- HEAD: فایلی که مشخص می‌کند هم‌اکنون روی کدام شاخه یا کامیت هستیم.
- Config: تنظیمات محلی پروژه (مثل remote url).
- Hooks: اسکریپت‌های خودکارسازی قبل/بعد از کامیت و...


**دستور ساخت:**
این پوشه با دستور `git init` ایجاد می‌شود. (همچنین دستور `git clone` نیز به طور خودکار آن را می‌سازد).


### ۲. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟
"اتمیک" بودن در مهندسی نرم‌افزار به مفهومی از "تجزیه‌ناپذیری" اشاره دارد. یعنی یک عملیات یا به طور کامل و موفق انجام می‌شود، یا اصلاً انجام نمی‌شود و هیچ اثر جانبی نیمه‌کاره‌ای باقی نمی‌گذارد.

-   **Atomic Commit:** یک کامیت اتمیک، کوچک‌ترین واحد منطقی و کامل از یک تغییر را در خود جای می‌دهد. به جای ثبت کردن چندین تغییر نامرتبط (مثلاً "رفع باگ پرداخت و تغییر رنگ هدر")، هر کامیت فقط و فقط یک کار را انجام می‌دهد (مثلاً "Feat: Add user authentication endpoint"). این کار بازبینی کد (Code Review)، بازگردانی تغییرات (Revert) و درک تاریخچه پروژه را بسیار ساده‌تر می‌کند.

-   **Atomic Pull-Request:** این مفهوم نیز مشابه است. یک PR اتمیک باید یک دغدغه یا فیچر خاص را حل کند. PR نباید مجموعه‌ای از چندین فیچر، باگ‌فیکس و ریفکتور نامرتبط باشد. یک PR اتمیک به ریویوئر اجازه می‌دهد تمرکز کند، سریع‌تر آن را بررسی و تأیید کند و در صورت بروز مشکل، کل تغییر با اطمینان بیشتری قابل بازگشت است.


### ۳. دستور `git reflog` چیست و چه کاربردی دارد؟
`git reflog` (Reference Log) یک مکانیزم داخلی در گیت است که تاریخچه‌ای از تمام تغییرات اشاره‌گر `HEAD` را ثبت می‌کند. به زبان ساده‌تر، این دستور تمام کارهایی که در مخزن محلی (Local Repository) خود انجام داده‌اید—مانند `checkout` کردن بین شاخه‌ها، `commit` کردن، `reset` کردن، یا `merge` کردن—را به ترتیب زمانی نگه می‌دارد.

**تفاوت با `git log`:**
-   `git log` تاریخچه خطی و عمومی کامیت‌های پروژه را نشان می‌دهد که بین تمام اعضای تیم به اشتراک گذاشته می‌شود.
-   `git reflog` تاریخچه خصوصی و محلی شماست. این لاگ هیچ‌وقت به مخزن ریموت (Remote) پوش نمی‌شود و فقط روی سیستم شما وجود دارد.

**کاربرد اصلی:**
**نجات دادن پروژه!** `reflog` برای بازیابی کامیت‌ها یا شاخه‌هایی که به نظر "حذف شده" یا "گم شده" می‌آیند، حیاتی است. برای مثال:
-   اگر با `git reset --hard` یک کامیت را حذف کنید، در `git log` دیگر دیده نمی‌شود، اما در `reflog` هنوز قابل دسترسی است.
-   اگر یک شاخه را به اشتباه حذف کنید، `reflog` به شما نشان می‌دهد که آخرین کامیت آن شاخه چه بوده تا بتوانید آن را بازیابی کنید.

این دستور مانند یک دفترچه یادداشت شخصی برای گیت عمل می‌کند و به شما اجازه می‌دهد به هر نقطه‌ای از تاریخچه کاری خود بازگردید، حتی اگر آن نقاط در تاریخچه اصلی پروژه ثبت نشده باشند.


### ۴. دستور `git cherry-pick` چیست و چه کاربردی دارد؟
`git cherry-pick` دستوری است که به شما اجازه می‌دهد یک یا چند کامیت خاص را از یک شاخه انتخاب کرده و آن‌ها را روی شاخه فعلی خود اعمال کنید. به جای ادغام (merge) کردن تمام تغییرات یک شاخه، شما مانند یک "گیلاس‌چین" فقط کامیت‌های دلخواه خود را برمی‌دارید.

**سناریوی کاربرد:**
فرض کنید روی یک شاخه `feature/new-design` کار می‌کنید و متوجه یک باگ در سیستم لاگین می‌شوید. آن باگ را در یک کامیت جداگانه (`fix: correct login validation`) روی همان شاخه `feature` ثبت می‌کنید. حالا می‌خواهید این فیکس را فوراً به شاخه `main` یا `develop` منتقل کنید، بدون اینکه کل فیچر ناقص `new-design` را با آن همراه کنید.

**فرایند کار:**
1.  هش (Hash) کامیت مورد نظر را از `git log` پیدا می‌کنید (مثلاً `a1b2c3d`).
2.  به شاخه‌ای که می‌خواهید کامیت را به آن منتقل کنید، `checkout` می‌کنید (مثلاً `git checkout develop`).
3.  دستور را اجرا می‌کنید: `git cherry-pick a1b2c3d`.

گیت یک کپی از آن کامیت را روی شاخه `develop` ایجاد می‌کند. کامیت اصلی در شاخه مبدأ دست‌نخورده باقی می‌ماند.

**مزایا:**
-   **کنترل دقیق:** فقط تغییراتی که نیاز دارید را منتقل می‌کنید.
-   **جلوگیری از مرج‌های بزرگ و غیرضروری:** برای اعمال یک فیکس کوچک، نیازی به مرج کردن کل یک فیچر نیست.

**هشدار:** استفاده نادرست از `cherry-pick` می‌تواند منجر به ایجاد کامیت‌های تکراری (Duplicate Commits) در تاریخچه شود و آن را پیچیده کند. معمولاً برای Hotfixها یا انتقال تغییرات بسیار خاص استفاده می‌شود.


### ۵. دستور `git stash` چیست و چه کاربردی دارد؟
`git stash` یک ابزار قدرتمند برای ذخیره موقت تغییراتی است که هنوز برای کامیت شدن آماده نیستند. این دستور تمام تغییرات `staged` و `unstaged` شما را در یک "پشته" (stack) موقت ذخیره می‌کند و ورکینگ دایرکتوری شما را به حالت آخرین کامیت (`HEAD`) برمی‌گرداند.

**سناریوی کاربرد اصلی (تعویض زمینه یا Context-Switching):**
شما در حال کار روی یک فیچر هستید و چندین فایل را تغییر داده‌اید، اما کارتان نیمه‌کاره است و نمی‌خواهید یک کامیت ناقص ایجاد کنید. ناگهان یک باگ فوری گزارش می‌شود و باید سریعاً به شاخه `main` بروید تا آن را برطرف کنید. اگر تلاش کنید `checkout` کنید، گیت به دلیل وجود تغییرات کامیت‌نشده به شما خطا می‌دهد.

**راه حل `stash`:**
1.  `git stash`: تمام تغییرات فعلی شما ذخیره شده و ورکینگ دایرکتوری تمیز می‌شود.
2.  `git checkout main`: حالا به راحتی شاخه را عوض می‌کنید و Hotfix را اعمال می‌کنید.
3.  `git checkout feature-branch`: به شاخه قبلی خود برمی‌گردید.
4.  `git stash pop`: آخرین مجموعه تغییرات ذخیره‌شده را از پشته خارج کرده و دوباره روی ورکینگ دایرکتوری شما اعمال می‌کند.

**دستورات کلیدی:**
-   `git stash save "message"`: ذخیره تغییرات با یک پیام توصیفی.
-   `git stash list`: نمایش لیست تمام stash-ها.
-   `git stash pop`: اعمال آخرین stash و حذف آن از لیست.
-   `git stash apply`: اعمال آخرین stash اما نگه داشتن آن در لیست (برای استفاده مجدد).
-   `git stash drop`: حذف یک stash خاص.


### ۶. دستور `git bisect` چیست و چه کاربردی دارد؟
`git bisect` یک ابزار دیباگینگ بسیار قدرتمند در گیت است که برای پیدا کردن کامیت دقیقی که باعث ایجاد یک باگ شده، استفاده می‌شود. این دستور از الگوریتم **جستجوی دودویی (Binary Search)** برای پیدا کردن سریع کامیت مجرم در میان تاریخچه طولانی پروژه بهره می‌برد.

**فرایند کار:**
1.  **شروع:** با دستور `git bisect start` فرایند را آغاز می‌کنید.
2.  **مشخص کردن کامیت "بد":** به گیت می‌گویید که در کامیت فعلی (`HEAD`) باگ وجود دارد: `git bisect bad`.
3.  **مشخص کردن کامیت "خوب":** یک کامیت قدیمی‌تر که مطمئن هستید باگ در آن وجود نداشته را مشخص می‌کنید: `git bisect good <commit-hash-or-tag>`.
4.  **تست:** گیت به صورت خودکار به کامیتی در وسط این بازه `checkout` می‌کند. شما باید کد را در این نقطه تست کنید تا ببینید آیا باگ وجود دارد یا نه.
5.  **تکرار:**
    -   اگر باگ **وجود داشت**، به گیت می‌گویید: `git bisect bad`.
    -   اگر باگ **وجود نداشت**، به گیت می‌گویید: `git bisect good`.
گیت این فرایند را تکرار می‌کند و در هر مرحله، محدوده جستجو را نصف می‌کند تا در نهایت به اولین کامیتی که باگ را معرفی کرده است، برسد و آن را به شما نمایش دهد.

**پایان:** پس از پیدا شدن کامیت مجرم، با دستور `git bisect reset` از این حالت خارج شده و به شاخه اصلی خود بازمی‌گردید.

این ابزار در پروژه‌های بزرگ که ممکن است صدها کامیت بین یک نسخه سالم و یک نسخه خراب وجود داشته باشد، فوق‌العاده کارآمد است و ساعت‌ها زمان دیباگینگ را ذخیره می‌کند.


### ۷. دستور `git blame` چیست و چه کاربردی دارد؟
`git blame` دستوری است که اطلاعات ویرایش هر خط از یک فایل را به شما نشان می‌دهد. این دستور مشخص می‌کند که چه کسی، در چه زمانی و در کدام کامیت، آخرین تغییر را روی هر سطر از کد اعمال کرده است.

**کاربردها:**
1.  **پیدا کردن مسئول کد (Accountability):** اگر یک قطعه کد کار نمی‌کند، می‌توانید بفهمید چه کسی آن را نوشته و برای راهنمایی به او مراجعه کنید (یا به قول معروف "مقصر" را پیدا کنید!).
2.  **درک زمینه (Context):** با پیدا کردن هش کامیت مربوط به یک خط کد، می‌توانید پیام کامیت (Commit Message) آن را بخوانید و دلیل نوشته شدن آن قطعه کد را متوجه شوید.
3.  **تاریخچه تغییرات:** مشاهده روند تکامل یک فایل خط به خط.

**نحوه استفاده:**
-   `git blame filename`: نمایش نام نویسنده و هش کامیت در کنار هر خط فایل.
-   در محیط‌های گرافیکی (مثل VS Code یا GitHub)، این قابلیت اغلب به صورت "Lens" روی خطوط کد فعال است و با کلیک روی هر خط، اطلاعات `blame` را نشان می‌دهد.
